import Pipeline, { EventDataMap } from './pipeline';
import Emittery from 'emittery';
import { MediaProcessorInterface } from './MediaProcessorInterface';
/**
 * Media processor class holding and running insertable streams pipeline.
 * The class should be created on the proper thread.
 * Options are:
 * - Application main thread when media processing wants to be performed in the main thread.
 * - Worker thread when media processing wants to be performed in a Web worker thread.
 */
declare class MediaProcessor extends Emittery<EventDataMap> implements MediaProcessorInterface {
    /**
     * @private
     */
    uuid_: string;
    /**
     * @private
     */
    pipeline_?: Pipeline;
    /**
     * @private
     */
    transformers_?: Array<Transformer>;
    /**
     * @private
     */
    readable_?: ReadableStream;
    /**
     * @private
     */
    writable_?: WritableStream;
    /**
     * @private
     */
    trackExpectedRate_: number;
    constructor();
    /**
    * Sets the expected rate of the track per second.
    * The media processor will use this number for calculating drops in the rate.
    * This could happen when the transformation will take more time than expected.
    * This will not cause an error, just warning to the client.
    * Mostly:
    * Video: 30 frames per second
    * Audio: 50 audio data per second for OPUS
    * In case of increased frame dropping rate a warning will be emitted according to info [here](/docs/intro#errors-and-warnings-listener).
    * ***This is an optional method.***
    * @param trackExpectedRate - number holds the predicted track rate.
    */
    setTrackExpectedRate(trackExpectedRate: number): void;
    /**
     * Starts running the tranformation logic performed by the media processor instance.
     * When running an instance of this class on a Web worker thread the call for this function should be made by the user. See example [here](/docs/intro#webworker-code).
     * When running an instance of this class on the application main thread there is no need to call this method given it will be called by the `MediaProcessorConnector` instance.
     *
     * @param readable Readable stream associated to the media source being processed.
     * @param writable Writable stream associated to the resulting media once processed.
     *
     * @returns
     */
    transform(readable: ReadableStream, writable: WritableStream): Promise<void>;
    /**
     * @private
     */
    transformInternal(): Promise<void>;
    /**
     * Sets an array of transfromer instances that will be hold and ran by the media processor instance.
     * See example [here](/docs/intro#main-code)
     *
     * @param transformers An array of transformer instances.
     *
     * @returns
     */
    setTransformers(transformers: Array<Transformer>): Promise<void>;
    /**
     * Stops running the tranformation logic performed by the media processor instance.
     * @returns
     */
    destroy(): Promise<void>;
}
export default MediaProcessor;
