/**
 * Any function which return promise
 * @internal
 */
export type AnyAsyncFunction = (...args: any) => Promise<any>;

/**
 * Any function
 * @internal
 */
export type AnyFunction = (...args: any) => any;

/**
 * Any class
 * @internal
 */
export type AnyClass = { new (...args: any): any; prototype: any };

/**
 * Any class
 * @internal
 */
export type Class<C> = { new (...args: any): C; prototype: any };

/**
 * Worker class
 * @internal
 */
export type WorkerClass = { new (): Worker };

/**
 * Map a given object/class/type to one where method are all asynchronous and attributes does not exist anymore
 * @internal
 * @example
 * ```ts
 * interface Test {
 *    anAttribute: number;
 *    aSyncMethod: ()=>number;
 *    anAsyncMethod: ()=>Promise<number>;
 * }
 *
 * interface AsWorkerized {
 *    aSyncMethod: ()=>Promise<number>;
 *    anAsyncMethod: ()=>Promise<number>;
 * }
 *
 * type workerized = Workerized<Test>; // same as AsWorkerized
 *
 *
 * ```
 */
export type Promisify<W extends Object> = {
  [K in keyof W]: W[K] extends AnyAsyncFunction
    ? (...args: Parameters<W[K]>) => ReturnType<W[K]>
    : W[K] extends AnyFunction
    ? (...args: Parameters<W[K]>) => Promise<ReturnType<W[K]>>
    : never;
};

/**
 * Promisify and object and add the function terminate to it.
 */
export type Workerized<W extends Object> = Promisify<W> & {
  terminate: () => Promise<void>;
  workerContext: {
    id: number;
    resolvers: CommandResolvers;
    worker?: Worker;
  };
};

/**
 * Sendable command type exchanged with worker
 * @internal
 */
export enum CommandType {
  INIT = "INIT", // Instanciate the worker class
  FORWARD = "FORWARD", // Forward the command to the instance
  TERMINATE = "TERMINATE", // Prepare the worker to be terminated
  GLOBALS_SYNC = "GLOBALS_SYNC", // Sync globals values
}

/**
 * Data format exchanged with workers
 * @internal
 */
export interface Command {
  id?: number;
  type?: CommandType;
  functionName?: string;
  args?: any[];
  result?: any[];
}

/**
 * Hold promises waiting to be resolved while the worker has finish the forwarding
 * @internal
 */
export type CommandResolvers = Map<number, (...args: any) => any>;

/**
 * Context of the worker during its life
 * @internal
 */
export interface WorkerContext {
  instance?: any;
}

export type GlobalGetter<T> = () => T;
export type GlobalSetter<T> = (value: T) => Promise<void>;
