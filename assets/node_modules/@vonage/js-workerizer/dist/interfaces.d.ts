/**
 * Any function which return promise
 * @internal
 */
export declare type AnyAsyncFunction = (...args: any) => Promise<any>;
/**
 * Any function
 * @internal
 */
export declare type AnyFunction = (...args: any) => any;
/**
 * Any class
 * @internal
 */
export declare type AnyClass = {
    new (...args: any): any;
    prototype: any;
};
/**
 * Any class
 * @internal
 */
export declare type Class<C> = {
    new (...args: any): C;
    prototype: any;
};
/**
 * Worker class
 * @internal
 */
export declare type WorkerClass = {
    new (): Worker;
};
/**
 * Map a given object/class/type to one where method are all asynchronous and attributes does not exist anymore
 * @internal
 * @example
 * ```ts
 * interface Test {
 *    anAttribute: number;
 *    aSyncMethod: ()=>number;
 *    anAsyncMethod: ()=>Promise<number>;
 * }
 *
 * interface AsWorkerized {
 *    aSyncMethod: ()=>Promise<number>;
 *    anAsyncMethod: ()=>Promise<number>;
 * }
 *
 * type workerized = Workerized<Test>; // same as AsWorkerized
 *
 *
 * ```
 */
export declare type Promisify<W extends Object> = {
    [K in keyof W]: W[K] extends AnyAsyncFunction ? (...args: Parameters<W[K]>) => ReturnType<W[K]> : W[K] extends AnyFunction ? (...args: Parameters<W[K]>) => Promise<ReturnType<W[K]>> : never;
};
/**
 * Promisify and object and add the function terminate to it.
 */
export declare type Workerized<W extends Object> = Promisify<W> & {
    terminate: () => Promise<void>;
    workerContext: {
        id: number;
        resolvers: CommandResolvers;
        worker?: Worker;
    };
};
/**
 * Sendable command type exchanged with worker
 * @internal
 */
export declare enum CommandType {
    INIT = "INIT",
    FORWARD = "FORWARD",
    TERMINATE = "TERMINATE",
    GLOBALS_SYNC = "GLOBALS_SYNC"
}
/**
 * Data format exchanged with workers
 * @internal
 */
export interface Command {
    id?: number;
    type?: CommandType;
    functionName?: string;
    args?: any[];
    result?: any[];
}
/**
 * Hold promises waiting to be resolved while the worker has finish the forwarding
 * @internal
 */
export declare type CommandResolvers = Map<number, (...args: any) => any>;
/**
 * Context of the worker during its life
 * @internal
 */
export interface WorkerContext {
    instance?: any;
}
export declare type GlobalGetter<T> = () => T;
export declare type GlobalSetter<T> = (value: T) => Promise<void>;
