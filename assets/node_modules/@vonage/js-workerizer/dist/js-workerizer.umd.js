(function(c,s){typeof exports=="object"&&typeof module<"u"?s(exports):typeof define=="function"&&define.amd?define(["exports"],s):(c=typeof globalThis<"u"?globalThis:c||self,s(c["js-workerizer"]={}))})(this,function(c){"use strict";const s={};var a=(e=>(e.INIT="INIT",e.FORWARD="FORWARD",e.TERMINATE="TERMINATE",e.GLOBALS_SYNC="GLOBALS_SYNC",e))(a||{});function g(e){return[ImageBitmap,ReadableStream,WritableStream].some(n=>e instanceof n)}let W=0;function w(e,i,n,t,o){const r=W++;return e.postMessage({id:r,type:i,functionName:n,args:t},t.filter(f=>g(f))),new Promise(f=>{o==null||o.set(r,f)})}function u(e,i){const{id:n,type:t}=e,o=Array.isArray(i)?i:[i];postMessage({id:n,type:t,result:i},o.filter(r=>g(r)))}const y={};function k(){return typeof WorkerGlobalScope<"u"&&self instanceof WorkerGlobalScope}async function b(){if(k())u({type:a.GLOBALS_SYNC},s);else{const e=[];for(const i in y){const{worker:n,resolvers:t}=y[i].workerContext;n&&e.push(w(n,a.GLOBALS_SYNC,"",[s],t))}await Promise.all(e)}}function d(e,i){if(Array.isArray(i))i.splice(0,i.length);else if(typeof i=="object")for(const n in i)delete i[n];for(const n in e)Array.isArray(e[n])?(i[n]=[],d(e[n],i[n])):typeof e[n]=="object"?(i[n]={},d(e[n],i[n])):i[n]=e[n]}async function m(e,i,n){const t=new i;if(t.addEventListener("message",async({data:r})=>{var l,f,A,I,S,N,T;switch(r.type){case a.GLOBALS_SYNC:r.id?((f=n.get((l=r.id)!=null?l:-1))==null||f(r.result),n.delete((A=r.id)!=null?A:-1)):(d((I=r.result)!=null?I:{},s),await b());break;default:(N=n.get((S=r.id)!=null?S:-1))==null||N(r.result),n.delete((T=r.id)!=null?T:-1)}}),!await w(t,a.INIT,"",[e.workerId,s],n))throw"Failed to instantiate workerized class";return t}let C=0;async function L(e,i,n){const t={},o=C++;return Object.getOwnPropertyNames(e.prototype).forEach(r=>{t[r]=(...l)=>w(i,a.FORWARD,r,l,n)}),t.terminate=async(...r)=>{const l=await w(i,a.TERMINATE,"",r,n);return delete y[o],i.terminate(),t.workerContext.worker=void 0,l},t.workerContext={id:o,worker:i,resolvers:n},y[o]=t,t}async function O(e,i){const n=new Map,t=await m(e,i,n);return L(e,t,n)}async function R(e,i){const{functionName:n,args:t}=e;if(!i.instance)throw"instance not initialized";if(!n)throw"missing function name to call";if(!i.instance[n])throw`undefined function [${n}] in class ${i.instance.constructor.workerId}`;u(e,await i.instance[n](...t!=null?t:[]))}const p={};function G(e,i){i.workerId=e,k()&&(p[i.workerId]=i)}function M(e,i){if(!e.args)throw"Missing className while initializing worker";const[n,t]=e.args,o=p[n];if(o)i.instance=new o(e.args.slice(1));else throw`unknown worker class ${n}`;d(t,s),u(e,typeof i.instance!==void 0)}async function z(e,i){const{args:n}=e;if(!i.instance)throw"instance not initialized";let t;i.instance.terminate&&(t=await i.instance.terminate(...n!=null?n:[])),u(e,t)}function E(e){if(!e.args)throw"Missing globals while syncing";d(e.args[0],s),u(e,{})}function h(){const e={};onmessage=async i=>{const n=i.data;switch(n.type){case a.INIT:M(n,e);break;case a.FORWARD:R(n,e);break;case a.TERMINATE:z(n,e);break;case a.GLOBALS_SYNC:E(n);break}}}k()&&h();function _(e,i){return s[e]||(s[e]=i),[()=>s[e],async n=>{s[e]=n,await b()}]}function B(e,i){return _(e,i)}c.CommandType=a,c.initWorker=h,c.registerGlobal=B,c.registerWorker=G,c.registeredWorkers=p,c.workerize=O,Object.defineProperties(c,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})});
